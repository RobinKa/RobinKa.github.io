{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["makeField3D","shape","getValue","field","x","row","y","d","z","push","gpu","GPU","fdCurlX3DA","createKernel","fieldY","fieldZ","this","thread","v","constants","gridSize","w","cellSize","output","fdCurlY3DA","fieldX","u","fdCurlZ3DA","fdCurlX3DB","fdCurlY3DB","fdCurlZ3DB","inplaceMulAddScalarField3D","a","b","s","length","simulator","data","stepElectric","dt","curlX","magneticFieldY","magneticFieldZ","curlY","magneticFieldX","curlZ","electricFieldX","electricFieldY","electricFieldZ","time","stepMagnetic","getData","_","permittivity","permeability","drawArrow","ctx","from","to","style","fillStyle","dx","dy","strokeStyle","beginPath","moveTo","lineTo","stroke","angle","Math","atan2","cos","sin","PI","closePath","fill","arc","r","magnitudeSquaredVector3D","clampMagnitudeVector3D","maxMag","magSq","mag","sqrt","clamp","min","max","value","Boolean","window","location","hostname","match","ReactDOM","render","canvasRef","useRef","useState","showElectric","setShowElectric","showMagnetic","setShowMagnetic","showPoynting","setShowPoynting","showEnergy","setShowEnergy","mouseDownPos","setMouseDownPos","redrawCanvas","useMemo","simulationData","current","getContext","fillRect","canvas","width","height","arrowLength","totalEnergy","totalElectricEnergy","totalMagneticEnergy","round","canvasCoords","electricValue","magneticValue","poyntingVector","electricEnergy","magneticEnergy","energy","depthColor","elClamped","magClamped","poyntingClamped","fillText","toFixed","getSignal","t","step","useCallback","stop","simData","sig","px","py","Promise","resolve","setTimeout","loop","useEffect","float","innerHeight","ref","onMouseDown","e","clientX","clientY","onMouseMove","onMouseUp","onClick","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1f9593b7.chunk.js","sourcesContent":["import React, { useRef, useCallback, useEffect, useMemo, useState } from 'react'\nimport { GPU } from \"gpu.js\"\n\nconst gridSize = 30\nconst cellSize = 0.1\n\nconst energyScale = 2\n\ntype Vector3D = [number, number, number]\n\ntype Field3D<T> = T[][][]\ntype ScalarField3D = Field3D<number>\n\nfunction makeField3D<T>(shape: [number, number, number], getValue: (coords: [number, number, number]) => T): Field3D<T> {\n    const field = []\n    for (let x = 0; x < shape[0]; x++) {\n        const row = []\n        for (let y = 0; y < shape[1]; y++) {\n            const d = []\n            for (let z = 0; z < shape[2]; z++) {\n                d.push(getValue([x, y, z]))\n            }\n            row.push(d)\n        }\n        field.push(row)\n    }\n    return field\n}\n\nconst gpu = new GPU()\n\nconst fdCurlX3DA = gpu.createKernel(function (fieldY: ScalarField3D, fieldZ: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const v = y + 1 >= this.constants.gridSize ? 0 : fieldZ[x][y + 1][z]\n    const w = z + 1 >= this.constants.gridSize ? 0 : fieldY[x][y][z + 1]\n\n    return ((v - fieldZ[x][y][z]) - (w - fieldY[x][y][z])) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\n\nconst fdCurlY3DA = gpu.createKernel(function (fieldX: ScalarField3D, fieldZ: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const u = x + 1 >= this.constants.gridSize ? 0 : fieldZ[x + 1][y][z]\n    const w = z + 1 >= this.constants.gridSize ? 0 : fieldX[x][y][z + 1]\n\n    return ((w - fieldX[x][y][z]) - (u - fieldZ[x][y][z])) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nconst fdCurlZ3DA = gpu.createKernel(function (fieldX: ScalarField3D, fieldY: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const u = x + 1 >= this.constants.gridSize ? 0 : fieldY[x + 1][y][z]\n    const v = y + 1 >= this.constants.gridSize ? 0 : fieldX[x][y + 1][z]\n\n    return ((u - fieldY[x][y][z]) - (v - fieldX[x][y][z])) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nconst fdCurlX3DB = gpu.createKernel(function (fieldY: ScalarField3D, fieldZ: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const v: number = y - 1 < 0 ? 0 : fieldZ[x][y - 1][z]\n    const w: number = z - 1 < 0 ? 0 : fieldY[x][y][z - 1]\n\n    return ((fieldZ[x][y][z] - v) - (fieldY[x][y][z] - w)) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nconst fdCurlY3DB = gpu.createKernel(function (fieldX: ScalarField3D, fieldZ: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const u: number = x - 1 < 0 ? 0 : fieldZ[x - 1][y][z]\n    const w: number = z - 1 < 0 ? 0 : fieldX[x][y][z - 1]\n\n    return ((fieldX[x][y][z] - w) - (fieldZ[x][y][z] - u)) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nconst fdCurlZ3DB = gpu.createKernel(function (fieldX: ScalarField3D, fieldY: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const u: number = x - 1 < 0 ? 0 : fieldY[x - 1][y][z]\n    const v: number = y - 1 < 0 ? 0 : fieldX[x][y - 1][z]\n\n    return ((fieldY[x][y][z] - u) - (fieldX[x][y][z] - v)) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nfunction inplaceMulAddScalarField3D(a: ScalarField3D, b: ScalarField3D, s: number) {\n    for (let x = 0; x < a.length; x++) {\n        for (let y = 0; y < a[0].length; y++) {\n            for (let z = 0; z < a[0][0].length; z++) {\n                a[x][y][z] += s * b[x][y][z]\n            }\n        }\n    }\n}\n\ntype SimulationData = {\n    time: number\n    electricFieldX: ScalarField3D\n    electricFieldY: ScalarField3D\n    electricFieldZ: ScalarField3D\n    magneticFieldX: ScalarField3D\n    magneticFieldY: ScalarField3D\n    magneticFieldZ: ScalarField3D\n    permittivity: ScalarField3D\n    permeability: ScalarField3D\n}\n\ninterface Simulator {\n    stepElectric: (dt: number) => void\n    stepMagnetic: (dt: number) => void\n    getData: () => SimulationData\n}\n\nclass FDTDSimulator implements Simulator {\n    private data: SimulationData\n\n    constructor(shape: [number, number, number]) {\n        this.data = {\n            time: 0,\n            electricFieldX: makeField3D<number>(shape, _ => 0),\n            electricFieldY: makeField3D<number>(shape, _ => 0),\n            electricFieldZ: makeField3D<number>(shape, _ => 0),\n            magneticFieldX: makeField3D<number>(shape, _ => 0),\n            magneticFieldY: makeField3D<number>(shape, _ => 0),\n            magneticFieldZ: makeField3D<number>(shape, _ => 0),\n            permittivity: makeField3D<number>(shape, (_) => 0),\n            permeability: makeField3D<number>(shape, (_) => 0),\n        }\n    }\n\n    stepElectric = (dt: number) => {\n        // d/dt E(x, t) = (curl B(x, t))/(µε)\n        const curlX = fdCurlX3DB(this.data.magneticFieldY, this.data.magneticFieldZ) as ScalarField3D\n        const curlY = fdCurlY3DB(this.data.magneticFieldX, this.data.magneticFieldZ) as ScalarField3D\n        const curlZ = fdCurlZ3DB(this.data.magneticFieldX, this.data.magneticFieldY) as ScalarField3D\n\n        inplaceMulAddScalarField3D(this.data.electricFieldX, curlX, dt)\n        inplaceMulAddScalarField3D(this.data.electricFieldY, curlY, dt)\n        inplaceMulAddScalarField3D(this.data.electricFieldZ, curlZ, dt)\n\n        this.data.time += dt / 2\n    }\n\n    stepMagnetic = (dt: number) => {\n        // d/dt B(x, t) = -curl E(x, t)\n        const curlX = fdCurlX3DA(this.data.electricFieldY, this.data.electricFieldZ) as ScalarField3D\n        const curlY = fdCurlY3DA(this.data.electricFieldX, this.data.electricFieldZ) as ScalarField3D\n        const curlZ = fdCurlZ3DA(this.data.electricFieldX, this.data.electricFieldY) as ScalarField3D\n\n        inplaceMulAddScalarField3D(this.data.magneticFieldX, curlX, -dt)\n        inplaceMulAddScalarField3D(this.data.magneticFieldY, curlY, -dt)\n        inplaceMulAddScalarField3D(this.data.magneticFieldZ, curlZ, -dt)\n\n        this.data.time += dt / 2\n    }\n\n    getData = () => this.data\n}\n\nconst simulator = new FDTDSimulator([gridSize, gridSize, gridSize])\n\nfunction drawArrow(ctx: CanvasRenderingContext2D, from: [number, number], to: [number, number], style: string) {\n    ctx.fillStyle = style\n\n    const r = 5\n    const dx = from[0] - to[0]\n    const dy = from[1] - to[1]\n\n    if (dx * dx + dy * dy > 1) {\n\n        ctx.strokeStyle = style\n        ctx.beginPath()\n        ctx.moveTo(from[0], from[1])\n        ctx.lineTo(to[0], to[1])\n        ctx.stroke()\n\n        ctx.beginPath()\n        let angle = Math.atan2(to[1] - from[1], to[0] - from[0])\n        let x = r * Math.cos(angle) + to[0]\n        let y = r * Math.sin(angle) + to[1]\n        ctx.moveTo(x, y)\n\n        angle += (1 / 3) * (2 * Math.PI)\n        x = r * Math.cos(angle) + to[0]\n        y = r * Math.sin(angle) + to[1]\n        ctx.lineTo(x, y)\n\n        angle += (1 / 3) * (2 * Math.PI)\n        x = r * Math.cos(angle) + to[0]\n        y = r * Math.sin(angle) + to[1]\n        ctx.lineTo(x, y)\n\n        ctx.closePath()\n        ctx.fill()\n    } else {\n        ctx.beginPath()\n        ctx.arc(from[0], from[1], r * 2 / 3, 0, 2 * Math.PI)\n        ctx.fill()\n    }\n}\n\nfunction crossVector3D(a: Vector3D, b: Vector3D): Vector3D {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0],\n    ]\n}\n\nfunction magnitudeSquaredVector3D(v: Vector3D) {\n    return v[0] * v[0] + v[1] * v[1] + v[2] * v[2]\n}\n\nfunction clampMagnitudeVector3D(maxMag: number, v: Vector3D): Vector3D {\n    const magSq = magnitudeSquaredVector3D(v)\n\n    if (magSq === 0 || magSq <= maxMag * maxMag) {\n        return v\n    }\n\n    const mag = Math.sqrt(magSq)\n\n    return [\n        maxMag * v[0] / mag,\n        maxMag * v[1] / mag,\n        maxMag * v[2] / mag\n    ]\n}\n\nfunction clamp(min: number, max: number, value: number) {\n    return Math.max(min, Math.min(max, value))\n}\n\nexport default function () {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n\n    const [showElectric, setShowElectric] = useState(false)\n    const [showMagnetic, setShowMagnetic] = useState(true)\n    const [showPoynting, setShowPoynting] = useState(false)\n    const [showEnergy, setShowEnergy] = useState(true)\n\n    const [mouseDownPos, setMouseDownPos] = useState<[number, number] | null>(null)\n\n    const redrawCanvas = useMemo(() => (simulationData: SimulationData) => {\n        if (canvasRef.current) {\n            const ctx = canvasRef.current.getContext(\"2d\")\n            if (ctx) {\n                ctx.fillStyle = \"black\"\n                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n\n                const cellSize = ctx.canvas.width / simulationData.electricFieldX.length\n                const arrowLength = cellSize / 2.5\n\n                let totalEnergy = 0\n                let totalElectricEnergy = 0\n                let totalMagneticEnergy = 0\n\n                for (let x = 0; x < simulationData.electricFieldX.length; x++) {\n                    for (let y = 0; y < simulationData.electricFieldX[0].length; y++) {\n                        //for (let z = 0; z < 1; z++) {\n                        const z = Math.round(simulationData.electricFieldX[0][0].length / 2); {\n                            const canvasCoords: [number, number] = [\n                                (x + 0.5) * cellSize + cellSize * z / (4 * simulationData.electricFieldX.length),\n                                (y + 0.5) * cellSize - cellSize * z / (4 * simulationData.electricFieldX.length)\n                            ]\n\n                            const electricValue: [number, number, number] = [simulationData.electricFieldX[x][y][z], simulationData.electricFieldY[x][y][z], simulationData.electricFieldZ[x][y][z]]\n                            const magneticValue: [number, number, number] = [simulationData.magneticFieldX[x][y][z], simulationData.magneticFieldY[x][y][z], simulationData.magneticFieldZ[x][y][z]]\n\n                            const poyntingVector = crossVector3D(electricValue, magneticValue)\n\n                            const electricEnergy = 0.5 * magnitudeSquaredVector3D(electricValue)\n                            const magneticEnergy = 0.5 * magnitudeSquaredVector3D(magneticValue)\n                            const energy = electricEnergy + magneticEnergy // + magnitudeVector3D(poyntingVector)\n\n                            totalEnergy += energy\n                            totalElectricEnergy += electricEnergy\n                            totalMagneticEnergy += magneticEnergy\n\n                            const depthColor = 255 * z / (simulationData.electricFieldX[0][0].length - 1)\n\n                            if (showEnergy) {\n                                ctx.strokeStyle = `rgb(${depthColor}, 255, ${depthColor})`\n                                ctx.beginPath()\n                                ctx.arc(canvasCoords[0], canvasCoords[1], arrowLength * Math.min(1, (energy / energyScale)), 0, 2 * Math.PI)\n                                ctx.stroke()\n                            }\n\n                            if (showElectric) {\n                                const elClamped = clampMagnitudeVector3D(1, electricValue)\n\n                                const elOffset: [number, number] = [\n                                    canvasCoords[0] + arrowLength * elClamped[0],\n                                    canvasCoords[1] + arrowLength * elClamped[1],\n                                ]\n\n                                drawArrow(ctx, canvasCoords, elOffset, `rgb(255, ${depthColor}, ${depthColor})`)\n                            }\n\n                            if (showMagnetic) {\n                                const magClamped = clampMagnitudeVector3D(1, magneticValue)\n\n                                const magOffset: [number, number] = [\n                                    canvasCoords[0] + arrowLength * magClamped[0],\n                                    canvasCoords[1] + arrowLength * magClamped[1],\n                                ]\n\n                                drawArrow(ctx, canvasCoords, magOffset, `rgb(${depthColor}, ${depthColor}, 255)`)\n                            }\n\n                            if (showPoynting) {\n                                const poyntingClamped = clampMagnitudeVector3D(energyScale, poyntingVector)\n\n                                const poyntingOffset: [number, number] = [\n                                    canvasCoords[0] + arrowLength * poyntingClamped[0] / energyScale,\n                                    canvasCoords[1] + arrowLength * poyntingClamped[1] / energyScale,\n                                ]\n\n                                drawArrow(ctx, canvasCoords, poyntingOffset, `rgb(${255 - depthColor}, 255, ${depthColor})`)\n                            }\n                        }\n                    }\n                }\n\n                ctx.fillStyle = \"white\"\n                ctx.fillText(`Time: ${simulationData.time.toFixed(2)}`, 10, 10)\n                ctx.fillStyle = \"lime\"\n                ctx.fillText(`Total energy: ${totalEnergy.toFixed(2)}`, 10, 20)\n                ctx.fillStyle = \"red\"\n                ctx.fillText(`Electric energy: ${totalElectricEnergy.toFixed(2)}`, 10, 30)\n                ctx.fillStyle = \"blue\"\n                ctx.fillText(`Magnetic energy: ${totalMagneticEnergy.toFixed(2)}`, 10, 40)\n            }\n        }\n    }, [canvasRef, showElectric, showMagnetic, showEnergy, showPoynting])\n\n    const getSignal = useMemo(() => {\n        return (t: number) => {\n            return [0, 0, 3]\n        }\n    }, [])\n\n    const step = useCallback(() => {\n        let stop = false\n\n        const loop = (async () => {\n            while (!stop) {\n                const simData = simulator.getData()\n\n                const dt = 0.01\n\n                if (mouseDownPos !== null && canvasRef.current) {\n                    let sig = getSignal(simData.time)\n\n                    const px = clamp(0, simData.electricFieldX.length - 1, Math.round(simData.electricFieldX.length * mouseDownPos[0] / canvasRef.current.width))\n                    const py = clamp(0, simData.electricFieldX[0].length - 1, Math.round(simData.electricFieldX[0].length * mouseDownPos[1] / canvasRef.current.height))\n\n                    for (let z = 0; z < gridSize; z++) {\n                        simData.electricFieldX[px][py][z] = sig[0]\n                        simData.electricFieldY[px][py][z] = sig[1]\n                        simData.electricFieldZ[px][py][z] = sig[2]\n                    }\n                }\n\n                simulator.stepMagnetic(dt)\n\n                if (mouseDownPos !== null && canvasRef.current) {\n                    let sig = getSignal(simData.time)\n\n                    const px = clamp(0, simData.electricFieldX.length - 1, Math.round(simData.electricFieldX.length * mouseDownPos[0] / canvasRef.current.width))\n                    const py = clamp(0, simData.electricFieldX[0].length - 1, Math.round(simData.electricFieldX[0].length * mouseDownPos[1] / canvasRef.current.height))\n\n                    for (let z = 0; z < gridSize; z++) {\n                        simData.electricFieldX[px][py][z] = sig[0]\n                        simData.electricFieldY[px][py][z] = sig[1]\n                        simData.electricFieldZ[px][py][z] = sig[2]\n                    }\n                }\n\n                simulator.stepElectric(dt)\n\n                redrawCanvas(simulator.getData())\n                await new Promise(resolve => setTimeout(resolve, 1000 * dt))\n            }\n        })\n\n        loop()\n\n        return () => { stop = true }\n    }, [redrawCanvas, getSignal, mouseDownPos, canvasRef])\n\n    useEffect(() => {\n        redrawCanvas(simulator.getData())\n    }, [redrawCanvas])\n\n    useEffect(step, [step])\n\n    return (\n        <div>\n            <div style={{ float: \"left\" }}>\n                <canvas width={window.innerHeight} height={window.innerHeight} ref={canvasRef}\n                    onMouseDown={e => setMouseDownPos([e.clientX, e.clientY])}\n                    onMouseMove={e => { if (mouseDownPos !== null) setMouseDownPos([e.clientX, e.clientY]) }}\n                    onMouseUp={_ => setMouseDownPos(null)}\n                />\n            </div>\n            <div>\n                <div><button onClick={() => setShowElectric(!showElectric)}>Toggle electric</button></div>\n                <div><button onClick={() => setShowMagnetic(!showMagnetic)}>Toggle magnetic</button></div>\n                <div><button onClick={() => setShowEnergy(!showEnergy)}>Toggle energy</button></div>\n                <div><button onClick={() => setShowPoynting(!showPoynting)}>Toggle poynting</button></div>\n            </div>\n        </div>\n    )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}