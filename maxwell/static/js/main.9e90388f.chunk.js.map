{"version":3,"sources":["simulator.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["makeEmptyScalarField3D","shape","field","i","push","values","addScalarField3DValue","x","y","z","value","canvasSize","window","innerWidth","innerHeight","gridSize","Math","ceil","simulator","cellSize","data","gpu","updateMagneticX","updateMagneticY","updateMagneticZ","updateElectricX","updateElectricY","updateElectricZ","stepElectric","dt","elX","electricFieldX","elY","electricFieldY","elZ","electricFieldZ","magX","magneticFieldX","magY","magneticFieldY","magZ","magneticFieldZ","time","stepMagnetic","getData","this","permittivity","permeability","cellCount","getAt","shapeX","shapeY","shapeZ","getX","index","getY","floor","getZ","GPU","createKernel","fieldY","fieldZ","magFieldX","thread","gx","constants","gridSizeX","gy","gridSizeY","gz","gridSizeZ","output","setFunctions","fieldX","magFieldY","magFieldZ","elFieldX","elFieldY","elFieldZ","makeRenderSimulatorCanvas","g","ox","oy","xa","ya","xb","yb","alphaX","alphaY","eAA","eAB","eBA","eBB","magXAA","magYAA","magZAA","magXAB","magYAB","magZAB","magXBA","magYBA","magZBA","magXBB","magYBB","magZBB","mAA","mAB","mBA","mBB","eMixTop","eMixBottom","eMix","max","min","mMixTop","mMixBottom","mMix","color","graphical","clamp","renderSim","signalStrength","signalPosition","mouseDownPos","Boolean","location","hostname","match","ReactDOM","render","drawCanvasRef","useRef","startLoop","useCallback","stop","a","simReady","resolveSimPromise","resolve","setTimeout","resolveDrawPromise","requestAnimationFrame","simPromise","Promise","drawPromise","race","simData","pow","current","px","width","py","height","sin","PI","mode","canvas","loop","useEffect","ref","onMouseDown","e","clientX","clientY","onMouseMove","onMouseUp","_","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9e90388f.chunk.js","sourcesContent":["import { GPU, IKernelRunShortcut } from \"gpu.js\"\r\n\r\nexport type FlatScalarField3D = {\r\n    values: number[]\r\n    shape: [number, number, number]\r\n}\r\n\r\nfunction makeEmptyScalarField3D(shape: [number, number, number]) {\r\n    const field = []\r\n    for (let i = 0; i < shape[0] * shape[1] * shape[2]; i++) {\r\n        field.push(0)\r\n    }\r\n    return { values: field, shape: shape }\r\n}\r\n\r\nexport function setScalarField3DValue(field: FlatScalarField3D, x: number, y: number, z: number, value: number) {\r\n    field.values[x + y * field.shape[0] + z * field.shape[0] * field.shape[1]] = value\r\n}\r\n\r\nexport function addScalarField3DValue(field: FlatScalarField3D, x: number, y: number, z: number, value: number) {\r\n    field.values[x + y * field.shape[0] + z * field.shape[0] * field.shape[1]] += value\r\n}\r\n\r\nexport function getScalarField3DValue(field: FlatScalarField3D, x: number, y: number, z: number) {\r\n    return field.values[x + y * field.shape[0] + z * field.shape[0] * field.shape[1]]\r\n}\r\n\r\nexport type SimulationData = {\r\n    time: number\r\n    electricFieldX: FlatScalarField3D\r\n    electricFieldY: FlatScalarField3D\r\n    electricFieldZ: FlatScalarField3D\r\n    magneticFieldX: FlatScalarField3D\r\n    magneticFieldY: FlatScalarField3D\r\n    magneticFieldZ: FlatScalarField3D\r\n    permittivity: FlatScalarField3D\r\n    permeability: FlatScalarField3D\r\n}\r\n\r\nexport interface Simulator {\r\n    stepElectric: (dt: number) => void\r\n    stepMagnetic: (dt: number) => void\r\n    getData: () => SimulationData\r\n}\r\n\r\nexport class FDTDSimulator implements Simulator {\r\n    private data: SimulationData\r\n\r\n    private gpu: GPU\r\n    private updateMagneticX: IKernelRunShortcut\r\n    private updateMagneticY: IKernelRunShortcut\r\n    private updateMagneticZ: IKernelRunShortcut\r\n    private updateElectricX: IKernelRunShortcut\r\n    private updateElectricY: IKernelRunShortcut\r\n    private updateElectricZ: IKernelRunShortcut\r\n\r\n    constructor(gridSize: [number, number, number], cellSize: number) {\r\n        this.data = {\r\n            time: 0,\r\n            electricFieldX: makeEmptyScalarField3D(gridSize),\r\n            electricFieldY: makeEmptyScalarField3D(gridSize),\r\n            electricFieldZ: makeEmptyScalarField3D(gridSize),\r\n            magneticFieldX: makeEmptyScalarField3D(gridSize),\r\n            magneticFieldY: makeEmptyScalarField3D(gridSize),\r\n            magneticFieldZ: makeEmptyScalarField3D(gridSize),\r\n            permittivity: makeEmptyScalarField3D(gridSize),\r\n            permeability: makeEmptyScalarField3D(gridSize),\r\n        }\r\n\r\n        const cellCount = gridSize[0] * gridSize[1] * gridSize[2]\r\n\r\n        this.gpu = new GPU()\r\n\r\n        function getAt(field: number[], shapeX: number, shapeY: number, shapeZ: number, x: number, y: number, z: number) {\r\n            if (x < 0 || x >= shapeX || y < 0 || y >= shapeY || z < 0 || z >= shapeZ) {\r\n                return 0\r\n            }\r\n\r\n            return field[x + y * shapeX + z * shapeX * shapeZ]\r\n        }\r\n\r\n        function getX(index: number, shapeX: number) {\r\n            return index % shapeX\r\n        }\r\n\r\n        function getY(index: number, shapeX: number, shapeY: number) {\r\n            return Math.floor(index / shapeX) % shapeY\r\n        }\r\n\r\n        function getZ(index: number, shapeX: number, shapeY: number, shapeZ: number) {\r\n            return Math.floor(index / (shapeX * shapeY)) % shapeZ\r\n        }\r\n\r\n        this.updateMagneticX = this.gpu.createKernel(function (fieldY: number[], fieldZ: number[], magFieldX: number[], dt: number) {\r\n            const index = Math.floor(this.thread.x)\r\n\r\n            const gx = this.constants.gridSizeX as number\r\n            const gy = this.constants.gridSizeY as number\r\n            const gz = this.constants.gridSizeZ as number\r\n            const cellSize = this.constants.cellSize as number\r\n\r\n            const x = getX(index, gx)\r\n            const y = getY(index, gx, gy)\r\n            const z = getZ(index, gx, gy, gz)\r\n\r\n            // d_Y Z - d_Z Y\r\n            return getAt(magFieldX, gx, gy, gz, x, y, z) - (dt / cellSize) * (\r\n                (getAt(fieldZ, gx, gy, gz, x, y + 1, z) - getAt(fieldZ, gx, gy, gz, x, y, z)))\r\n        }, {\r\n            output: [cellCount],\r\n            constants: { cellSize: cellSize, gridSizeX: gridSize[0], gridSizeY: gridSize[1], gridSizeZ: gridSize[2] }\r\n        }).setFunctions([getX, getY, getZ, getAt])\r\n\r\n\r\n        this.updateMagneticY = this.gpu.createKernel(function (fieldX: number[], fieldZ: number[], magFieldY: number[], dt: number) {\r\n            const index = Math.floor(this.thread.x)\r\n\r\n            const gx = this.constants.gridSizeX as number\r\n            const gy = this.constants.gridSizeY as number\r\n            const gz = this.constants.gridSizeZ as number\r\n            const cellSize = this.constants.cellSize as number\r\n\r\n            const x = getX(index, gx)\r\n            const y = getY(index, gx, gy)\r\n            const z = getZ(index, gx, gy, gz)\r\n\r\n            // d_Z X - d_X Z\r\n            return getAt(magFieldY, gx, gy, gz, x, y, z) - (dt / cellSize) * (\r\n                -(getAt(fieldZ, gx, gy, gz, x + 1, y, z) - getAt(fieldZ, gx, gy, gz, x, y, z)))\r\n        }, {\r\n            output: [cellCount],\r\n            constants: { cellSize: cellSize, gridSizeX: gridSize[0], gridSizeY: gridSize[1], gridSizeZ: gridSize[2] }\r\n        }).setFunctions([getX, getY, getZ, getAt])\r\n\r\n        this.updateMagneticZ = this.gpu.createKernel(function (fieldX: number[], fieldY: number[], magFieldZ: number[], dt: number) {\r\n            const index = Math.floor(this.thread.x)\r\n\r\n            const gx = this.constants.gridSizeX as number\r\n            const gy = this.constants.gridSizeY as number\r\n            const gz = this.constants.gridSizeZ as number\r\n            const cellSize = this.constants.cellSize as number\r\n\r\n            const x = getX(index, gx)\r\n            const y = getY(index, gx, gy)\r\n            const z = getZ(index, gx, gy, gz)\r\n\r\n            // d_X Y - d_Y X\r\n            return getAt(magFieldZ, gx, gy, gz, x, y, z) - (dt / cellSize) * (\r\n                (getAt(fieldY, gx, gy, gz, x + 1, y, z) - getAt(fieldY, gx, gy, gz, x, y, z)) -\r\n                (getAt(fieldX, gx, gy, gz, x, y + 1, z) - getAt(fieldX, gx, gy, gz, x, y, z)))\r\n        }, {\r\n            output: [cellCount],\r\n            constants: { cellSize: cellSize, gridSizeX: gridSize[0], gridSizeY: gridSize[1], gridSizeZ: gridSize[2] }\r\n        }).setFunctions([getX, getY, getZ, getAt])\r\n\r\n        this.updateElectricX = this.gpu.createKernel(function (fieldY: number[], fieldZ: number[], elFieldX: number[], dt: number) {\r\n            const index = Math.floor(this.thread.x)\r\n\r\n            const gx = this.constants.gridSizeX as number\r\n            const gy = this.constants.gridSizeY as number\r\n            const gz = this.constants.gridSizeZ as number\r\n            const cellSize = this.constants.cellSize as number\r\n\r\n            const x = getX(index, gx)\r\n            const y = getY(index, gx, gy)\r\n            const z = getZ(index, gx, gy, gz)\r\n\r\n            // d_Y Z - d_Z Y\r\n            return getAt(elFieldX, gx, gy, gz, x, y, z) + (dt / cellSize) * (\r\n                (getAt(fieldZ, gx, gy, gz, x, y, z) - getAt(fieldZ, gx, gy, gz, x, y - 1, z)))\r\n        }, {\r\n            output: [cellCount],\r\n            constants: { cellSize: cellSize, gridSizeX: gridSize[0], gridSizeY: gridSize[1], gridSizeZ: gridSize[2] }\r\n        }).setFunctions([getX, getY, getZ, getAt])\r\n\r\n        this.updateElectricY = this.gpu.createKernel(function (fieldX: number[], fieldZ: number[], elFieldY: number[], dt: number) {\r\n            const index = Math.floor(this.thread.x)\r\n\r\n            const gx = this.constants.gridSizeX as number\r\n            const gy = this.constants.gridSizeY as number\r\n            const gz = this.constants.gridSizeZ as number\r\n            const cellSize = this.constants.cellSize as number\r\n\r\n            const x = getX(index, gx)\r\n            const y = getY(index, gx, gy)\r\n            const z = getZ(index, gx, gy, gz)\r\n\r\n            // d_Z X - d_X Z\r\n            return getAt(elFieldY, gx, gy, gz, x, y, z) + (dt / cellSize) * (\r\n                -(getAt(fieldZ, gx, gy, gz, x, y, z) - getAt(fieldZ, gx, gy, gz, x - 1, y, z)))\r\n        }, {\r\n            output: [cellCount],\r\n            constants: { cellSize: cellSize, gridSizeX: gridSize[0], gridSizeY: gridSize[1], gridSizeZ: gridSize[2] }\r\n        }).setFunctions([getX, getY, getZ, getAt])\r\n\r\n        this.updateElectricZ = this.gpu.createKernel(function (fieldX: number[], fieldY: number[], elFieldZ: number[], dt: number) {\r\n            const index = Math.floor(this.thread.x)\r\n\r\n            const gx = this.constants.gridSizeX as number\r\n            const gy = this.constants.gridSizeY as number\r\n            const gz = this.constants.gridSizeZ as number\r\n            const cellSize = this.constants.cellSize as number\r\n\r\n            const x = getX(index, gx)\r\n            const y = getY(index, gx, gy)\r\n            const z = getZ(index, gx, gy, gz)\r\n\r\n            // d_X Y - d_Y X\r\n            return getAt(elFieldZ, gx, gy, gz, x, y, z) + (dt / cellSize) * (\r\n                (getAt(fieldY, gx, gy, gz, x, y, z) - getAt(fieldY, gx, gy, gz, x - 1, y, z)) -\r\n                (getAt(fieldX, gx, gy, gz, x, y, z) - getAt(fieldX, gx, gy, gz, x, y - 1, z)))\r\n        }, {\r\n            output: [cellCount],\r\n            constants: { cellSize: cellSize, gridSizeX: gridSize[0], gridSizeY: gridSize[1], gridSizeZ: gridSize[2] }\r\n        }).setFunctions([getX, getY, getZ, getAt])\r\n    }\r\n\r\n    stepElectric = (dt: number) => {\r\n        const elX = this.data.electricFieldX.values\r\n        const elY = this.data.electricFieldY.values\r\n        const elZ = this.data.electricFieldZ.values\r\n        const magX = this.data.magneticFieldX.values\r\n        const magY = this.data.magneticFieldY.values\r\n        const magZ = this.data.magneticFieldZ.values\r\n\r\n        // d/dt E(x, t) = (curl B(x, t))/(µε)\r\n        this.data.electricFieldX.values = this.updateElectricX(magY, magZ, elX, dt) as number[]\r\n        this.data.electricFieldY.values = this.updateElectricY(magX, magZ, elY, dt) as number[]\r\n        this.data.electricFieldZ.values = this.updateElectricZ(magX, magY, elZ, dt) as number[]\r\n\r\n        this.data.time += dt / 2\r\n    }\r\n\r\n    stepMagnetic = (dt: number) => {\r\n        const elX = this.data.electricFieldX.values\r\n        const elY = this.data.electricFieldY.values\r\n        const elZ = this.data.electricFieldZ.values\r\n        const magX = this.data.magneticFieldX.values\r\n        const magY = this.data.magneticFieldY.values\r\n        const magZ = this.data.magneticFieldZ.values\r\n\r\n        // d/dt B(x, t) = -curl E(x, t)\r\n        this.data.magneticFieldX.values = this.updateMagneticX(elY, elZ, magX, dt) as number[]\r\n        this.data.magneticFieldY.values = this.updateMagneticY(elX, elZ, magY, dt) as number[]\r\n        this.data.magneticFieldZ.values = this.updateMagneticZ(elX, elY, magZ, dt) as number[]\r\n\r\n        this.data.time += dt / 2\r\n    }\r\n\r\n    getData = () => this.data\r\n}","import React, { useRef, useCallback, useEffect } from 'react'\nimport { GPU } from \"gpu.js\"\nimport { FDTDSimulator, addScalarField3DValue } from \"./simulator\"\n\nconst canvasSize = [window.innerWidth, window.innerHeight]\n\nconst dt = 0.01\nconst gridSizeX = 400\nconst gridSize: [number, number, number] = [gridSizeX, Math.ceil(gridSizeX / canvasSize[0] * canvasSize[1]), 1]\nconst cellSize = 0.03\n\nconst simulator = new FDTDSimulator(gridSize, cellSize)\n\nconst makeRenderSimulatorCanvas = (g: GPU) => {\n    function getAt(field: number[], shapeX: number, shapeY: number, shapeZ: number, x: number, y: number, z: number) {\n        if (x < 0 || x >= shapeX || y < 0 || y >= shapeY || z < 0 || z >= shapeZ) {\n            return 0\n        }\n\n        return field[x + y * shapeX + z * shapeX * shapeZ]\n    }\n\n    return g.createKernel(function (electricFieldX: number[], electricFieldY: number[], electricFieldZ: number[], magneticFieldX: number[], magneticFieldY: number[], magneticFieldZ: number[]) {\n        const gx = this.constants.gridSizeX as number\n        const gy = this.constants.gridSizeY as number\n        const gz = this.constants.gridSizeZ as number\n\n        const ox = this.output.x as number\n        const oy = this.output.y as number\n\n        const x = gx * this.thread.x! / ox\n        const y = gy * (1 - this.thread.y! / oy)\n        const xa = Math.floor(x)\n        const ya = Math.floor(y)\n        const xb = xa + 1\n        const yb = ya + 1\n\n        const alphaX = xb === xa ? 0 : (x - xa) / (xb - xa)\n        const alphaY = yb === ya ? 0 : (y - ya) / (yb - ya)\n\n        const z = Math.floor(gz / 2)\n\n        const eAA = getAt(electricFieldX, gx, gy, gz, xa, ya, z) * getAt(electricFieldX, gx, gy, gz, xa, ya, z) + getAt(electricFieldY, gx, gy, gz, xa, ya, z) * getAt(electricFieldY, gx, gy, gz, xa, ya, z) + getAt(electricFieldZ, gx, gy, gz, xa, ya, z) * getAt(electricFieldZ, gx, gy, gz, xa, ya, z)\n        const eAB = getAt(electricFieldX, gx, gy, gz, xa, yb, z) * getAt(electricFieldX, gx, gy, gz, xa, yb, z) + getAt(electricFieldY, gx, gy, gz, xa, yb, z) * getAt(electricFieldY, gx, gy, gz, xa, yb, z) + getAt(electricFieldZ, gx, gy, gz, xa, yb, z) * getAt(electricFieldZ, gx, gy, gz, xa, yb, z)\n        const eBA = getAt(electricFieldX, gx, gy, gz, xb, ya, z) * getAt(electricFieldX, gx, gy, gz, xb, ya, z) + getAt(electricFieldY, gx, gy, gz, xb, ya, z) * getAt(electricFieldY, gx, gy, gz, xb, ya, z) + getAt(electricFieldZ, gx, gy, gz, xb, ya, z) * getAt(electricFieldZ, gx, gy, gz, xb, ya, z)\n        const eBB = getAt(electricFieldX, gx, gy, gz, xb, yb, z) * getAt(electricFieldX, gx, gy, gz, xb, yb, z) + getAt(electricFieldY, gx, gy, gz, xb, yb, z) * getAt(electricFieldY, gx, gy, gz, xb, yb, z) + getAt(electricFieldZ, gx, gy, gz, xb, yb, z) * getAt(electricFieldZ, gx, gy, gz, xb, yb, z)\n\n        // Magnetic field is offset from electric field, so get value at +0.5 by interpolating 0 and 1\n        const magXAA = (getAt(magneticFieldX, gx, gy, gz, xa, ya, z) + getAt(magneticFieldX, gx, gy, gz, xa + 1, ya + 1, z)) / 2\n        const magYAA = (getAt(magneticFieldY, gx, gy, gz, xa, ya, z) + getAt(magneticFieldY, gx, gy, gz, xa + 1, ya + 1, z)) / 2\n        const magZAA = (getAt(magneticFieldZ, gx, gy, gz, xa, ya, z) + getAt(magneticFieldZ, gx, gy, gz, xa + 1, ya + 1, z)) / 2\n        const magXAB = (getAt(magneticFieldX, gx, gy, gz, xa, yb, z) + getAt(magneticFieldX, gx, gy, gz, xa + 1, yb + 1, z)) / 2\n        const magYAB = (getAt(magneticFieldY, gx, gy, gz, xa, yb, z) + getAt(magneticFieldY, gx, gy, gz, xa + 1, yb + 1, z)) / 2\n        const magZAB = (getAt(magneticFieldZ, gx, gy, gz, xa, yb, z) + getAt(magneticFieldZ, gx, gy, gz, xa + 1, yb + 1, z)) / 2\n        const magXBA = (getAt(magneticFieldX, gx, gy, gz, xb, ya, z) + getAt(magneticFieldX, gx, gy, gz, xb + 1, ya + 1, z)) / 2\n        const magYBA = (getAt(magneticFieldY, gx, gy, gz, xb, ya, z) + getAt(magneticFieldY, gx, gy, gz, xb + 1, ya + 1, z)) / 2\n        const magZBA = (getAt(magneticFieldZ, gx, gy, gz, xb, ya, z) + getAt(magneticFieldZ, gx, gy, gz, xb + 1, ya + 1, z)) / 2\n        const magXBB = (getAt(magneticFieldX, gx, gy, gz, xb, yb, z) + getAt(magneticFieldX, gx, gy, gz, xb + 1, yb + 1, z)) / 2\n        const magYBB = (getAt(magneticFieldY, gx, gy, gz, xb, yb, z) + getAt(magneticFieldY, gx, gy, gz, xb + 1, yb + 1, z)) / 2\n        const magZBB = (getAt(magneticFieldZ, gx, gy, gz, xb, yb, z) + getAt(magneticFieldZ, gx, gy, gz, xb + 1, yb + 1, z)) / 2\n\n        const mAA = magXAA * magXAA + magYAA * magYAA + magZAA * magZAA\n        const mAB = magXAB * magXAB + magYAB * magYAB + magZAB * magZAB\n        const mBA = magXBA * magXBA + magYBA * magYBA + magZBA * magZBA\n        const mBB = magXBB * magXBB + magYBB * magYBB + magZBB * magZBB\n\n        const scale = 50\n\n        const eMixTop = alphaX * eBA + (1 - alphaX) * eAA\n        const eMixBottom = alphaX * eBB + (1 - alphaX) * eAB\n        const eMix = Math.max(0, Math.min(scale, alphaY * eMixBottom + (1 - alphaY) * eMixTop))\n\n        const mMixTop = alphaX * mBA + (1 - alphaX) * mAA\n        const mMixBottom = alphaX * mBB + (1 - alphaX) * mAB\n\n        const mMix = Math.max(0, Math.min(scale, alphaY * mMixBottom + (1 - alphaY) * mMixTop))\n\n        this.color(eMix / scale, 0, mMix / scale)\n        //this.color(eAA, 0, 0)\n        //this.color(alphaX, alphaY, 0)\n        //this.color(getAt(electricFieldZ, gx, gy, gz, xa, ya, z) * getAt(electricFieldZ, gx, gy, gz, xa, ya, z), 0, 0)\n    }, {\n        output: [canvasSize[0], canvasSize[1]],\n        constants: { gridSizeX: gridSize[0], gridSizeY: gridSize[1], gridSizeZ: gridSize[2] },\n        graphical: true\n    }).setFunctions([getAt])\n}\n\nfunction clamp(min: number, max: number, value: number) {\n    return Math.max(min, Math.min(max, value))\n}\n\nlet renderSim: any = null\nlet signalStrength = 0\nlet signalPosition = [0, 0]\nlet mouseDownPos: [number, number] | null = null\n\nexport default function () {\n    const drawCanvasRef = useRef<HTMLCanvasElement>(null)\n\n    const startLoop = useCallback(() => {\n        let stop = false\n\n        const loop = (async () => {\n            let simReady = false\n            const resolveSimPromise = (resolve: any) => setTimeout(() => { simReady = true; resolve() }, 1000 * dt)\n            const resolveDrawPromise = (resolve: any) => requestAnimationFrame(resolve)\n\n            let simPromise = new Promise(resolveSimPromise)\n            let drawPromise = new Promise(resolveDrawPromise)\n\n            while (!stop) {\n                await Promise.race([simPromise, drawPromise])\n\n                const simData = simulator.getData()\n\n                if (simReady || simulator.getData().time <= 0) {\n                    if (mouseDownPos !== null) {\n                        signalPosition = mouseDownPos\n                        signalStrength = Math.min(10000, signalStrength + dt * 10000)\n                    }\n\n                    signalStrength *= Math.pow(0.1, dt)\n\n                    if (signalStrength > 1 && drawCanvasRef.current) {\n                        const px = clamp(0, simData.electricFieldX.shape[0] - 1, Math.floor(simData.electricFieldX.shape[0] * signalPosition[0] / drawCanvasRef.current.width))\n                        const py = clamp(0, simData.electricFieldX.shape[1] - 1, Math.floor(simData.electricFieldX.shape[1] * signalPosition[1] / drawCanvasRef.current.height))\n\n                        for (let z = 0; z < simData.electricFieldX.shape[2]; z++) {\n                            //addScalarField3DValue(simData.electricFieldX, px, py, z, sig[0] * dt / 2)\n                            //addScalarField3DValue(simData.electricFieldY, px, py, z, sig[1] * dt / 2)\n                            addScalarField3DValue(simData.electricFieldZ, px, py, z, Math.sin(2 * 2 * Math.PI * simData.time) * signalStrength * dt)\n                        }\n                    }\n\n                    simulator.stepMagnetic(dt)\n                    simulator.stepElectric(dt)\n\n                    simPromise = new Promise(resolveSimPromise)\n                } else {\n                    if (renderSim === null && drawCanvasRef.current !== null) {\n                        renderSim = makeRenderSimulatorCanvas(new GPU({ mode: \"webgl2\", canvas: drawCanvasRef.current }))\n                    }\n\n                    if (renderSim !== null) {\n                        renderSim(simData.electricFieldX.values, simData.electricFieldY.values, simData.electricFieldZ.values,\n                            simData.magneticFieldX.values, simData.magneticFieldY.values, simData.magneticFieldZ.values)\n                    }\n\n                    drawPromise = new Promise(resolveDrawPromise)\n                }\n\n                simReady = false\n                await Promise.race([simPromise, drawPromise])\n            }\n        })\n\n        loop()\n\n        return () => { stop = true }\n    }, [])\n\n    useEffect(startLoop, [startLoop])\n\n    return (\n        <canvas width={canvasSize[0]} height={canvasSize[1]} ref={drawCanvasRef}\n            onMouseDown={e => mouseDownPos = [e.clientX, e.clientY]}\n            onMouseMove={e => { if (mouseDownPos !== null) mouseDownPos = [e.clientX, e.clientY] }}\n            onMouseUp={_ => mouseDownPos = null} />\n    )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}