{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["makeField3D","shape","getValue","field","x","row","y","d","z","push","gpu","GPU","fdCurlX3DA","createKernel","fieldY","fieldZ","this","thread","v","output","w","constants","cellSize","fdCurlY3DA","fieldX","u","gridSize","fdCurlZ3DA","fdCurlX3DB","fdCurlY3DB","fdCurlZ3DB","inplaceMulAddScalarField3D","a","b","s","length","simulator","data","stepElectric","dt","curlX","magneticFieldY","magneticFieldZ","curlY","magneticFieldX","curlZ","electricFieldX","electricFieldY","electricFieldZ","time","stepMagnetic","getData","_","permittivity","permeability","clamp","min","max","value","Math","renderSim","Boolean","window","location","hostname","match","ReactDOM","render","drawCanvasRef","useRef","useState","mouseDownPos","setMouseDownPos","getSignal","useMemo","t","sin","PI","step","useCallback","stop","simData","current","sig","px","round","width","py","height","g","mode","canvas","xb","ceil","yb","xa","ya","alphaX","alphaY","eAA","eAB","eBA","eBB","mAA","mAB","mBA","mBB","eMixTop","eMixBottom","eMix","mMixTop","mMixBottom","mMix","color","setOutput","innerHeight","setConstants","setGraphical","Promise","resolve","setTimeout","loop","useEffect","id","style","float","ref","onMouseDown","e","clientX","clientY","onMouseMove","onMouseUp","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.817ff80a.chunk.js","sourcesContent":["import React, { useRef, useCallback, useEffect, useMemo, useState } from 'react'\nimport { GPU } from \"gpu.js\"\n\nconst gridSize = 50\nconst cellSize = 0.03\n\ntype Vector3D = [number, number, number]\n\ntype Field3D<T> = T[][][]\ntype ScalarField3D = Field3D<number>\n\nfunction makeField3D<T>(shape: [number, number, number], getValue: (coords: [number, number, number]) => T): Field3D<T> {\n    const field = []\n    for (let x = 0; x < shape[0]; x++) {\n        const row = []\n        for (let y = 0; y < shape[1]; y++) {\n            const d = []\n            for (let z = 0; z < shape[2]; z++) {\n                d.push(getValue([x, y, z]))\n            }\n            row.push(d)\n        }\n        field.push(row)\n    }\n    return field\n}\n\nconst gpu = new GPU()\n\nconst fdCurlX3DA = gpu.createKernel(function (fieldY: ScalarField3D, fieldZ: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const v = y + 1 >= this.output.y! ? 0 : fieldZ[x][y + 1][z]\n    const w = z + 1 >= this.output.z! ? 0 : fieldY[x][y][z + 1]\n\n    return ((v - fieldZ[x][y][z]) - (w - fieldY[x][y][z])) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { cellSize: cellSize } })\n\n\nconst fdCurlY3DA = gpu.createKernel(function (fieldX: ScalarField3D, fieldZ: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const u = x + 1 >= this.constants.gridSize ? 0 : fieldZ[x + 1][y][z]\n    const w = z + 1 >= this.constants.gridSize ? 0 : fieldX[x][y][z + 1]\n\n    return ((w - fieldX[x][y][z]) - (u - fieldZ[x][y][z])) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nconst fdCurlZ3DA = gpu.createKernel(function (fieldX: ScalarField3D, fieldY: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const u = x + 1 >= this.constants.gridSize ? 0 : fieldY[x + 1][y][z]\n    const v = y + 1 >= this.constants.gridSize ? 0 : fieldX[x][y + 1][z]\n\n    return ((u - fieldY[x][y][z]) - (v - fieldX[x][y][z])) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nconst fdCurlX3DB = gpu.createKernel(function (fieldY: ScalarField3D, fieldZ: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const v: number = y - 1 < 0 ? 0 : fieldZ[x][y - 1][z]\n    const w: number = z - 1 < 0 ? 0 : fieldY[x][y][z - 1]\n\n    return ((fieldZ[x][y][z] - v) - (fieldY[x][y][z] - w)) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nconst fdCurlY3DB = gpu.createKernel(function (fieldX: ScalarField3D, fieldZ: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const u: number = x - 1 < 0 ? 0 : fieldZ[x - 1][y][z]\n    const w: number = z - 1 < 0 ? 0 : fieldX[x][y][z - 1]\n\n    return ((fieldX[x][y][z] - w) - (fieldZ[x][y][z] - u)) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nconst fdCurlZ3DB = gpu.createKernel(function (fieldX: ScalarField3D, fieldY: ScalarField3D) {\n    const x = this.thread.z!\n    const y = this.thread.y!\n    const z = this.thread.x!\n\n    const u: number = x - 1 < 0 ? 0 : fieldY[x - 1][y][z]\n    const v: number = y - 1 < 0 ? 0 : fieldX[x][y - 1][z]\n\n    return ((fieldY[x][y][z] - u) - (fieldX[x][y][z] - v)) / (this.constants.cellSize as number)\n}, { output: [gridSize, gridSize, gridSize], constants: { gridSize: gridSize, cellSize: cellSize } })\n\nfunction inplaceMulAddScalarField3D(a: ScalarField3D, b: ScalarField3D, s: number) {\n    for (let x = 0; x < a.length; x++) {\n        for (let y = 0; y < a[0].length; y++) {\n            for (let z = 0; z < a[0][0].length; z++) {\n                a[x][y][z] += s * b[x][y][z]\n            }\n        }\n    }\n}\n\ntype SimulationData = {\n    time: number\n    electricFieldX: ScalarField3D\n    electricFieldY: ScalarField3D\n    electricFieldZ: ScalarField3D\n    magneticFieldX: ScalarField3D\n    magneticFieldY: ScalarField3D\n    magneticFieldZ: ScalarField3D\n    permittivity: ScalarField3D\n    permeability: ScalarField3D\n}\n\ninterface Simulator {\n    stepElectric: (dt: number) => void\n    stepMagnetic: (dt: number) => void\n    getData: () => SimulationData\n}\n\nclass FDTDSimulator implements Simulator {\n    private data: SimulationData\n\n    constructor(shape: [number, number, number]) {\n        this.data = {\n            time: 0,\n            electricFieldX: makeField3D<number>(shape, _ => 0),\n            electricFieldY: makeField3D<number>(shape, _ => 0),\n            electricFieldZ: makeField3D<number>(shape, _ => 0),\n            magneticFieldX: makeField3D<number>(shape, _ => 0),\n            magneticFieldY: makeField3D<number>(shape, _ => 0),\n            magneticFieldZ: makeField3D<number>(shape, _ => 0),\n            permittivity: makeField3D<number>(shape, (_) => 0),\n            permeability: makeField3D<number>(shape, (_) => 0),\n        }\n    }\n\n    stepElectric = (dt: number) => {\n        // d/dt E(x, t) = (curl B(x, t))/(µε)\n        const curlX = fdCurlX3DB(this.data.magneticFieldY, this.data.magneticFieldZ) as ScalarField3D\n        const curlY = fdCurlY3DB(this.data.magneticFieldX, this.data.magneticFieldZ) as ScalarField3D\n        const curlZ = fdCurlZ3DB(this.data.magneticFieldX, this.data.magneticFieldY) as ScalarField3D\n\n        inplaceMulAddScalarField3D(this.data.electricFieldX, curlX, dt)\n        inplaceMulAddScalarField3D(this.data.electricFieldY, curlY, dt)\n        inplaceMulAddScalarField3D(this.data.electricFieldZ, curlZ, dt)\n\n        this.data.time += dt / 2\n    }\n\n    stepMagnetic = (dt: number) => {\n        // d/dt B(x, t) = -curl E(x, t)\n        const curlX = fdCurlX3DA(this.data.electricFieldY, this.data.electricFieldZ) as ScalarField3D\n        const curlY = fdCurlY3DA(this.data.electricFieldX, this.data.electricFieldZ) as ScalarField3D\n        const curlZ = fdCurlZ3DA(this.data.electricFieldX, this.data.electricFieldY) as ScalarField3D\n\n        inplaceMulAddScalarField3D(this.data.magneticFieldX, curlX, -dt)\n        inplaceMulAddScalarField3D(this.data.magneticFieldY, curlY, -dt)\n        inplaceMulAddScalarField3D(this.data.magneticFieldZ, curlZ, -dt)\n\n        this.data.time += dt / 2\n    }\n\n    getData = () => this.data\n}\n\nconst simulator = new FDTDSimulator([gridSize, gridSize, gridSize])\n\nconst drawCanvasSize = 400\n\nconst makeRenderSimulatorCanvas = (g: GPU) =>\n    g.createKernel(function (electricFieldX: ScalarField3D, electricFieldY: ScalarField3D, electricFieldZ: ScalarField3D, magneticFieldX: ScalarField3D, magneticFieldY: ScalarField3D, magneticFieldZ: ScalarField3D) {\n        const x = (this.constants.gridSize as number) * this.thread.x! / (this.output.x as number)\n        const y = (this.constants.gridSize as number) * -this.thread.y! / (this.output.y as number)\n        const xb = Math.ceil(x)\n        const yb = Math.ceil(y)\n        const xa = xb - 1\n        const ya = yb - 1\n\n        const alphaX = (x - xa) / (xb - xa)\n        const alphaY = (y - ya) / (yb - ya)\n\n        const z = Math.round((this.constants.gridSize as number) / 2)\n\n        const eAA = electricFieldX[xa][ya][z] * electricFieldX[xa][ya][z] + electricFieldY[xa][ya][z] * electricFieldY[xa][ya][z] + electricFieldZ[xa][ya][z] * electricFieldZ[xa][ya][z]\n        const eAB = electricFieldX[xa][yb][z] * electricFieldX[xa][yb][z] + electricFieldY[xa][yb][z] * electricFieldY[xa][yb][z] + electricFieldZ[xa][yb][z] * electricFieldZ[xa][yb][z]\n        const eBA = electricFieldX[xb][ya][z] * electricFieldX[xb][ya][z] + electricFieldY[xb][ya][z] * electricFieldY[xb][ya][z] + electricFieldZ[xb][ya][z] * electricFieldZ[xb][ya][z]\n        const eBB = electricFieldX[xb][yb][z] * electricFieldX[xb][yb][z] + electricFieldY[xb][yb][z] * electricFieldY[xb][yb][z] + electricFieldZ[xb][yb][z] * electricFieldZ[xb][yb][z]\n\n        const mAA = magneticFieldX[xa][ya][z] * magneticFieldX[xa][ya][z] + magneticFieldY[xa][ya][z] * magneticFieldY[xa][ya][z] + magneticFieldZ[xa][ya][z] * magneticFieldZ[xa][ya][z]\n        const mAB = magneticFieldX[xa][yb][z] * magneticFieldX[xa][yb][z] + magneticFieldY[xa][yb][z] * magneticFieldY[xa][yb][z] + magneticFieldZ[xa][yb][z] * magneticFieldZ[xa][yb][z]\n        const mBA = magneticFieldX[xb][ya][z] * magneticFieldX[xb][ya][z] + magneticFieldY[xb][ya][z] * magneticFieldY[xb][ya][z] + magneticFieldZ[xb][ya][z] * magneticFieldZ[xb][ya][z]\n        const mBB = magneticFieldX[xb][yb][z] * magneticFieldX[xb][yb][z] + magneticFieldY[xb][yb][z] * magneticFieldY[xb][yb][z] + magneticFieldZ[xb][yb][z] * magneticFieldZ[xb][yb][z]\n\n        const eMixTop = alphaX * eBA + (1 - alphaX) * eAA\n        const eMixBottom = alphaX * eBB + (1 - alphaX) * eAB\n        const eMix = Math.max(0, Math.min(2, alphaY * eMixBottom + (1 - alphaY) * eMixTop))\n\n        const mMixTop = alphaX * mBA + (1 - alphaX) * mAA\n        const mMixBottom = alphaX * mBB + (1 - alphaX) * mAB\n        const mMix = Math.max(0, Math.min(2, alphaY * mMixBottom + (1 - alphaY) * mMixTop))\n\n        this.color(eMix / 2, eMix / 2 * mMix / 2, mMix / 2)\n    }).setOutput([window.innerHeight, window.innerHeight]).setConstants({ gridSize: gridSize }).setGraphical(true)\n\n\nfunction drawArrow(ctx: CanvasRenderingContext2D, from: [number, number], to: [number, number], style: string) {\n    ctx.fillStyle = style\n\n    const r = 5\n    const dx = from[0] - to[0]\n    const dy = from[1] - to[1]\n\n    if (dx * dx + dy * dy > 1) {\n\n        ctx.strokeStyle = style\n        ctx.beginPath()\n        ctx.moveTo(from[0], from[1])\n        ctx.lineTo(to[0], to[1])\n        ctx.stroke()\n\n        ctx.beginPath()\n        let angle = Math.atan2(to[1] - from[1], to[0] - from[0])\n        let x = r * Math.cos(angle) + to[0]\n        let y = r * Math.sin(angle) + to[1]\n        ctx.moveTo(x, y)\n\n        angle += (1 / 3) * (2 * Math.PI)\n        x = r * Math.cos(angle) + to[0]\n        y = r * Math.sin(angle) + to[1]\n        ctx.lineTo(x, y)\n\n        angle += (1 / 3) * (2 * Math.PI)\n        x = r * Math.cos(angle) + to[0]\n        y = r * Math.sin(angle) + to[1]\n        ctx.lineTo(x, y)\n\n        ctx.closePath()\n        ctx.fill()\n    } else {\n        ctx.beginPath()\n        ctx.arc(from[0], from[1], r * 2 / 3, 0, 2 * Math.PI)\n        ctx.fill()\n    }\n}\n\nfunction crossVector3D(a: Vector3D, b: Vector3D): Vector3D {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0],\n    ]\n}\n\nfunction magnitudeSquaredVector3D(v: Vector3D) {\n    return v[0] * v[0] + v[1] * v[1] + v[2] * v[2]\n}\n\nfunction clampMagnitudeVector3D(maxMag: number, v: Vector3D): Vector3D {\n    const magSq = magnitudeSquaredVector3D(v)\n\n    if (magSq === 0 || magSq <= maxMag * maxMag) {\n        return v\n    }\n\n    const mag = Math.sqrt(magSq)\n\n    return [\n        maxMag * v[0] / mag,\n        maxMag * v[1] / mag,\n        maxMag * v[2] / mag\n    ]\n}\n\nfunction clamp(min: number, max: number, value: number) {\n    return Math.max(min, Math.min(max, value))\n}\n\nlet renderSim: any = null\n\nexport default function () {\n    const drawCanvasRef = useRef<HTMLCanvasElement>(null)\n\n    const [showElectric, setShowElectric] = useState(false)\n    const [showMagnetic, setShowMagnetic] = useState(false)\n    const [showPoynting, setShowPoynting] = useState(false)\n    const [showEnergy, setShowEnergy] = useState(true)\n\n    const [mouseDownPos, setMouseDownPos] = useState<[number, number] | null>(null)\n\n    /*const redrawCanvas = useMemo(() => (simulationData: SimulationData) => {\n        if (drawCanvasRef.current && (showElectric || showMagnetic || showEnergy || showPoynting)) {\n            const ctx = drawCanvasRef.current.getContext(\"2d\")\n            if (ctx) {\n                const cellSize = ctx.canvas.width / simulationData.electricFieldX.length\n                const arrowLength = cellSize / 2.5\n\n                let totalEnergy = 0\n                let totalElectricEnergy = 0\n                let totalMagneticEnergy = 0\n\n                for (let x = 0; x < simulationData.electricFieldX.length; x++) {\n                    for (let y = 0; y < simulationData.electricFieldX[0].length; y++) {\n                        //for (let z = 0; z < 1; z++) {\n                        const z = Math.round(simulationData.electricFieldX[0][0].length / 2); {\n                            const canvasCoords: [number, number] = [\n                                (x + 0.5) * cellSize + cellSize * z / (4 * simulationData.electricFieldX.length),\n                                (y + 0.5) * cellSize - cellSize * z / (4 * simulationData.electricFieldX.length)\n                            ]\n\n                            const electricValue: [number, number, number] = [simulationData.electricFieldX[x][y][z], simulationData.electricFieldY[x][y][z], simulationData.electricFieldZ[x][y][z]]\n                            const magneticValue: [number, number, number] = [simulationData.magneticFieldX[x][y][z], simulationData.magneticFieldY[x][y][z], simulationData.magneticFieldZ[x][y][z]]\n\n                            const poyntingVector = crossVector3D(electricValue, magneticValue)\n\n                            const electricEnergy = 0.5 * magnitudeSquaredVector3D(electricValue)\n                            const magneticEnergy = 0.5 * magnitudeSquaredVector3D(magneticValue)\n                            const energy = electricEnergy + magneticEnergy // + magnitudeVector3D(poyntingVector)\n\n                            totalEnergy += energy\n                            totalElectricEnergy += electricEnergy\n                            totalMagneticEnergy += magneticEnergy\n\n                            const depthColor = 255 * z / (simulationData.electricFieldX[0][0].length - 1)\n\n                            if (showEnergy) {\n                                ctx.strokeStyle = `rgb(${depthColor}, 255, ${depthColor})`\n                                ctx.beginPath()\n                                ctx.arc(canvasCoords[0], canvasCoords[1], arrowLength * Math.min(1, (energy / energyScale)), 0, 2 * Math.PI)\n                                ctx.stroke()\n                            }\n\n                            if (showElectric) {\n                                const elClamped = clampMagnitudeVector3D(1, electricValue)\n\n                                const elOffset: [number, number] = [\n                                    canvasCoords[0] + arrowLength * elClamped[0],\n                                    canvasCoords[1] + arrowLength * elClamped[1],\n                                ]\n\n                                drawArrow(ctx, canvasCoords, elOffset, `rgb(255, ${depthColor}, ${depthColor})`)\n                            }\n\n                            if (showMagnetic) {\n                                const magClamped = clampMagnitudeVector3D(1, magneticValue)\n\n                                const magOffset: [number, number] = [\n                                    canvasCoords[0] + arrowLength * magClamped[0],\n                                    canvasCoords[1] + arrowLength * magClamped[1],\n                                ]\n\n                                drawArrow(ctx, canvasCoords, magOffset, `rgb(${depthColor}, ${depthColor}, 255)`)\n                            }\n\n                            if (showPoynting) {\n                                const poyntingClamped = clampMagnitudeVector3D(energyScale, poyntingVector)\n\n                                const poyntingOffset: [number, number] = [\n                                    canvasCoords[0] + arrowLength * poyntingClamped[0] / energyScale,\n                                    canvasCoords[1] + arrowLength * poyntingClamped[1] / energyScale,\n                                ]\n\n                                drawArrow(ctx, canvasCoords, poyntingOffset, `rgb(${255 - depthColor}, 255, ${depthColor})`)\n                            }\n                        }\n                    }\n                }\n\n                ctx.fillStyle = \"white\"\n                ctx.fillText(`Time: ${simulationData.time.toFixed(2)}`, 10, 10)\n                ctx.fillStyle = \"lime\"\n                ctx.fillText(`Total energy: ${totalEnergy.toFixed(2)}`, 10, 20)\n                ctx.fillStyle = \"red\"\n                ctx.fillText(`Electric energy: ${totalElectricEnergy.toFixed(2)}`, 10, 30)\n                ctx.fillStyle = \"blue\"\n                ctx.fillText(`Magnetic energy: ${totalMagneticEnergy.toFixed(2)}`, 10, 40)\n            }\n        }\n    }, [drawCanvasRef, showElectric, showMagnetic, showEnergy, showPoynting])*/\n\n    const getSignal = useMemo(() => {\n        return (t: number) => {\n            return [0, 0, 3 * Math.sin(2 * Math.PI * t)]\n        }\n    }, [])\n\n    const step = useCallback(() => {\n        let stop = false\n\n        const loop = (async () => {\n            while (!stop) {\n                const simData = simulator.getData()\n\n                const dt = 0.01\n\n                if (mouseDownPos !== null && drawCanvasRef.current) {\n                    let sig = getSignal(simData.time)\n\n                    const px = clamp(0, simData.electricFieldX.length - 1, Math.round(simData.electricFieldX.length * mouseDownPos[0] / drawCanvasRef.current.width))\n                    const py = clamp(0, simData.electricFieldX[0].length - 1, Math.round(simData.electricFieldX[0].length * mouseDownPos[1] / drawCanvasRef.current.height))\n\n                    for (let z = 0; z < gridSize; z++) {\n                        simData.electricFieldX[px][py][z] = sig[0]\n                        simData.electricFieldY[px][py][z] = sig[1]\n                        simData.electricFieldZ[px][py][z] = sig[2]\n                    }\n                }\n\n                simulator.stepMagnetic(dt)\n\n                if (mouseDownPos !== null && drawCanvasRef.current) {\n                    let sig = getSignal(simData.time)\n\n                    const px = clamp(0, simData.electricFieldX.length - 1, Math.round(simData.electricFieldX.length * mouseDownPos[0] / drawCanvasRef.current.width))\n                    const py = clamp(0, simData.electricFieldX[0].length - 1, Math.round(simData.electricFieldX[0].length * mouseDownPos[1] / drawCanvasRef.current.height))\n\n                    for (let z = 0; z < gridSize; z++) {\n                        simData.electricFieldX[px][py][z] = sig[0]\n                        simData.electricFieldY[px][py][z] = sig[1]\n                        simData.electricFieldZ[px][py][z] = sig[2]\n                    }\n                }\n\n                simulator.stepElectric(dt)\n\n                if (renderSim === null && drawCanvasRef.current !== null) {\n                    renderSim = makeRenderSimulatorCanvas(new GPU({ mode: \"webgl\", canvas: drawCanvasRef.current }))\n                }\n\n                if (renderSim !== null) {\n                    renderSim(simulator.getData().electricFieldX, simulator.getData().electricFieldY, simulator.getData().electricFieldZ,\n                        simulator.getData().magneticFieldX, simulator.getData().magneticFieldY, simulator.getData().magneticFieldZ)\n                }\n\n                await new Promise(resolve => setTimeout(resolve, 1000 * dt))\n            }\n        })\n\n        loop()\n\n        return () => { stop = true }\n    }, [getSignal, mouseDownPos, drawCanvasRef])\n\n    useEffect(step, [step])\n\n    return (\n        <div id=\"main\">\n            <div style={{ float: \"left\" }}>\n                <canvas width={drawCanvasSize} height={drawCanvasSize} ref={drawCanvasRef}\n                    onMouseDown={e => setMouseDownPos([e.clientX, e.clientY])}\n                    onMouseMove={e => { if (mouseDownPos !== null) setMouseDownPos([e.clientX, e.clientY]) }}\n                    onMouseUp={_ => setMouseDownPos(null)} />\n            </div>\n            {/*<div>\n                <div><button onClick={() => setShowElectric(!showElectric)}>Toggle electric</button></div>\n                <div><button onClick={() => setShowMagnetic(!showMagnetic)}>Toggle magnetic</button></div>\n                <div><button onClick={() => setShowEnergy(!showEnergy)}>Toggle energy</button></div>\n                <div><button onClick={() => setShowPoynting(!showPoynting)}>Toggle poynting</button></div>\n            </div>*/}\n        </div>\n    )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}