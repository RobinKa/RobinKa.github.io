{"version":3,"sources":["simulator.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["makeField3D","shape","getValue","field","x","row","y","d","z","push","canvasSize","window","innerWidth","innerHeight","dt","gridSize","Math","ceil","simulator","cellSize","data","gpu","updateMagneticX","updateMagneticY","updateMagneticZ","updateElectricX","updateElectricY","updateElectricZ","stepElectric","electricFieldX","magneticFieldY","magneticFieldZ","electricFieldY","magneticFieldX","electricFieldZ","time","stepMagnetic","getData","this","_","permittivity","permeability","reverseGridSize","i","length","reverse","GPU","createKernel","fieldY","fieldZ","magFieldX","thread","v","output","constants","fieldX","magFieldY","u","magFieldZ","elFieldX","elFieldY","elFieldZ","clamp","min","max","value","renderSim","Boolean","location","hostname","match","ReactDOM","render","drawCanvasRef","useRef","useState","mouseDownPos","setMouseDownPos","getSignal","useMemo","t","step","useCallback","stop","a","Promise","resolve","setTimeout","simData","current","sig","px","floor","width","py","height","g","mode","canvas","gridSizeX","gridSizeY","xa","ya","xb","yb","alphaX","alphaY","round","gridSizeZ","eAA","eAB","eBA","eBB","magXAA","magYAA","magZAA","magXAB","magYAB","magZAB","magXBA","magYBA","magZBA","magXBB","magYBB","magZBB","mAA","mAB","mBA","mBB","eMixTop","eMixBottom","eMix","mMixTop","mMixBottom","mMix","color","graphical","loop","useEffect","ref","onMouseDown","e","clientX","clientY","onMouseMove","onMouseUp","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.54e30585.chunk.js","sourcesContent":["import { GPU, IKernelRunShortcut } from \"gpu.js\"\r\n\r\nexport type Field3D<T> = T[][][]\r\nexport type ScalarField3D = Field3D<number>\r\n\r\nexport function makeField3D<T>(shape: [number, number, number], getValue: (coords: [number, number, number]) => T): Field3D<T> {\r\n    const field = []\r\n    for (let x = 0; x < shape[0]; x++) {\r\n        const row = []\r\n        for (let y = 0; y < shape[1]; y++) {\r\n            const d = []\r\n            for (let z = 0; z < shape[2]; z++) {\r\n                d.push(getValue([x, y, z]))\r\n            }\r\n            row.push(d)\r\n        }\r\n        field.push(row)\r\n    }\r\n    return field\r\n}\r\n\r\nexport type SimulationData = {\r\n    time: number\r\n    electricFieldX: ScalarField3D\r\n    electricFieldY: ScalarField3D\r\n    electricFieldZ: ScalarField3D\r\n    magneticFieldX: ScalarField3D\r\n    magneticFieldY: ScalarField3D\r\n    magneticFieldZ: ScalarField3D\r\n    permittivity: ScalarField3D\r\n    permeability: ScalarField3D\r\n}\r\n\r\nexport interface Simulator {\r\n    stepElectric: (dt: number) => void\r\n    stepMagnetic: (dt: number) => void\r\n    getData: () => SimulationData\r\n}\r\n\r\nfunction reverse<T>(x: T[]) {\r\n    const y = []\r\n    for (let i = x.length - 1; i >= 0; i--) {\r\n        y.push(x[i])\r\n    }\r\n    return y\r\n}\r\n\r\nexport class FDTDSimulator implements Simulator {\r\n    private data: SimulationData\r\n\r\n    private gpu: GPU\r\n    private updateMagneticX: IKernelRunShortcut\r\n    private updateMagneticY: IKernelRunShortcut\r\n    private updateMagneticZ: IKernelRunShortcut\r\n    private updateElectricX: IKernelRunShortcut\r\n    private updateElectricY: IKernelRunShortcut\r\n    private updateElectricZ: IKernelRunShortcut\r\n\r\n    constructor(gridSize: [number, number, number], cellSize: number) {\r\n        this.data = {\r\n            time: 0,\r\n            electricFieldX: makeField3D<number>(gridSize, _ => 0),\r\n            electricFieldY: makeField3D<number>(gridSize, _ => 0),\r\n            electricFieldZ: makeField3D<number>(gridSize, _ => 0),\r\n            magneticFieldX: makeField3D<number>(gridSize, _ => 0),\r\n            magneticFieldY: makeField3D<number>(gridSize, _ => 0),\r\n            magneticFieldZ: makeField3D<number>(gridSize, _ => 0),\r\n            permittivity: makeField3D<number>(gridSize, (_) => 0),\r\n            permeability: makeField3D<number>(gridSize, (_) => 0),\r\n        }\r\n\r\n        const reverseGridSize = reverse(gridSize)\r\n\r\n        this.gpu = new GPU()\r\n\r\n        this.updateMagneticX = this.gpu.createKernel(function (fieldY: ScalarField3D, fieldZ: ScalarField3D, magFieldX: ScalarField3D, dt: number) {\r\n            const x = this.thread.z!\r\n            const y = this.thread.y!\r\n            const z = this.thread.x!\r\n\r\n            const v = y + 1 >= this.output.y! ? 0 : fieldZ[x][y + 1][z]\r\n            //const w = z + 1 >= this.output.x! ? 0 : fieldY[x][y][z + 1]\r\n\r\n            // d_Y Z - d_Z Y\r\n            return magFieldX[x][y][z] - dt * ((v - fieldZ[x][y][z]) - (0/*w - fieldY[x][y][z]*/)) / (this.constants.cellSize as number)\r\n        }, { output: reverseGridSize, constants: { cellSize: cellSize } })\r\n\r\n\r\n        this.updateMagneticY = this.gpu.createKernel(function (fieldX: ScalarField3D, fieldZ: ScalarField3D, magFieldY: ScalarField3D, dt: number) {\r\n            const x = this.thread.z!\r\n            const y = this.thread.y!\r\n            const z = this.thread.x!\r\n\r\n            const u = x + 1 >= this.output.z! ? 0 : fieldZ[x + 1][y][z]\r\n            //const w = z + 1 >= this.output.x! ? 0 : fieldX[x][y][z + 1]\r\n\r\n            // d_Z X - d_X Z\r\n            return magFieldY[x][y][z] - dt * ((0/*w - fieldX[x][y][z]*/) - (u - fieldZ[x][y][z])) / (this.constants.cellSize as number)\r\n        }, { output: reverseGridSize, constants: { cellSize: cellSize } })\r\n\r\n        this.updateMagneticZ = this.gpu.createKernel(function (fieldX: ScalarField3D, fieldY: ScalarField3D, magFieldZ: ScalarField3D, dt: number) {\r\n            const x = this.thread.z!\r\n            const y = this.thread.y!\r\n            const z = this.thread.x!\r\n\r\n            const u = x + 1 >= this.output.z! ? 0 : fieldY[x + 1][y][z]\r\n            const v = y + 1 >= this.output.y! ? 0 : fieldX[x][y + 1][z]\r\n\r\n            // d_X Y - d_Y X\r\n            return magFieldZ[x][y][z] - dt * ((u - fieldY[x][y][z]) - (v - fieldX[x][y][z])) / (this.constants.cellSize as number)\r\n        }, { output: reverseGridSize, constants: { cellSize: cellSize } })\r\n\r\n        this.updateElectricX = this.gpu.createKernel(function (fieldY: ScalarField3D, fieldZ: ScalarField3D, elFieldX: ScalarField3D, dt: number) {\r\n            const x = this.thread.z!\r\n            const y = this.thread.y!\r\n            const z = this.thread.x!\r\n\r\n            const v = y - 1 < 0 ? 0 : fieldZ[x][y - 1][z]\r\n            //const w = z - 1 < 0 ? 0 : fieldY[x][y][z - 1]\r\n\r\n            // d_Y Z - d_Z Y\r\n            return elFieldX[x][y][z] + dt * ((fieldZ[x][y][z] - v) - (0/*fieldY[x][y][z] - w*/)) / (this.constants.cellSize as number)\r\n        }, { output: reverseGridSize, constants: { cellSize: cellSize } })\r\n\r\n        this.updateElectricY = this.gpu.createKernel(function (fieldX: ScalarField3D, fieldZ: ScalarField3D, elFieldY: ScalarField3D, dt: number) {\r\n            const x = this.thread.z!\r\n            const y = this.thread.y!\r\n            const z = this.thread.x!\r\n\r\n            const u = x - 1 < 0 ? 0 : fieldZ[x - 1][y][z]\r\n            //const w = z - 1 < 0 ? 0 : fieldX[x][y][z - 1]\r\n\r\n            // d_Z X - d_X Z\r\n            return elFieldY[x][y][z] + dt * ((0/*fieldX[x][y][z] - w*/) - (fieldZ[x][y][z] - u)) / (this.constants.cellSize as number)\r\n        }, { output: reverseGridSize, constants: { cellSize: cellSize } })\r\n\r\n        this.updateElectricZ = this.gpu.createKernel(function (fieldX: ScalarField3D, fieldY: ScalarField3D, elFieldZ: ScalarField3D, dt: number) {\r\n            const x = this.thread.z!\r\n            const y = this.thread.y!\r\n            const z = this.thread.x!\r\n\r\n            const u = x - 1 < 0 ? 0 : fieldY[x - 1][y][z]\r\n            const v = y - 1 < 0 ? 0 : fieldX[x][y - 1][z]\r\n\r\n            // d_X Y - d_Y X\r\n            return elFieldZ[x][y][z] + dt * ((fieldY[x][y][z] - u) - (fieldX[x][y][z] - v)) / (this.constants.cellSize as number)\r\n        }, { output: reverseGridSize, constants: { cellSize: cellSize } })\r\n    }\r\n\r\n    stepElectric = (dt: number) => {\r\n        // d/dt E(x, t) = (curl B(x, t))/(µε)\r\n        this.data.electricFieldX = this.updateElectricX(this.data.magneticFieldY, this.data.magneticFieldZ, this.data.electricFieldX, dt) as ScalarField3D\r\n        this.data.electricFieldY = this.updateElectricY(this.data.magneticFieldX, this.data.magneticFieldZ, this.data.electricFieldY, dt) as ScalarField3D\r\n        this.data.electricFieldZ = this.updateElectricZ(this.data.magneticFieldX, this.data.magneticFieldY, this.data.electricFieldZ, dt) as ScalarField3D\r\n\r\n        this.data.time += dt / 2\r\n    }\r\n\r\n    stepMagnetic = (dt: number) => {\r\n        // d/dt B(x, t) = -curl E(x, t)\r\n        this.data.magneticFieldX = this.updateMagneticX(this.data.electricFieldY, this.data.electricFieldZ, this.data.magneticFieldX, dt) as ScalarField3D\r\n        this.data.magneticFieldY = this.updateMagneticY(this.data.electricFieldX, this.data.electricFieldZ, this.data.magneticFieldY, dt) as ScalarField3D\r\n        this.data.magneticFieldZ = this.updateMagneticZ(this.data.electricFieldX, this.data.electricFieldY, this.data.magneticFieldZ, dt) as ScalarField3D\r\n\r\n        this.data.time += dt / 2\r\n    }\r\n\r\n    getData = () => this.data\r\n}","import React, { useRef, useCallback, useEffect, useMemo, useState } from 'react'\nimport { GPU } from \"gpu.js\"\nimport { ScalarField3D, FDTDSimulator } from \"./simulator\"\n\nconst canvasSize = [window.innerWidth, window.innerHeight]\n\nconst dt = 0.005\nconst gridSizeX = 120\nconst gridSize: [number, number, number] = [gridSizeX, Math.ceil(gridSizeX / canvasSize[0] * canvasSize[1]), 1]\nconst cellSize = 0.01\n\nconst simulator = new FDTDSimulator(gridSize, cellSize)\n\nconst makeRenderSimulatorCanvas = (g: GPU) =>\n    g.createKernel(function (electricFieldX: ScalarField3D, electricFieldY: ScalarField3D, electricFieldZ: ScalarField3D, magneticFieldX: ScalarField3D, magneticFieldY: ScalarField3D, magneticFieldZ: ScalarField3D) {\n        const x = (this.constants.gridSizeX as number) * this.thread.x! / (this.output.x as number)\n        const y = (this.constants.gridSizeY as number) * this.thread.y! / (this.output.y as number)\n        const xa = Math.floor(x)\n        const ya = Math.floor(y)\n        const xb = xa + 1\n        const yb = ya + 1\n\n        const alphaX = xb === xa ? 0 : (x - xa) / (xb - xa)\n        const alphaY = yb === ya ? 0 : (y - ya) / (yb - ya)\n\n        const z = Math.round((this.constants.gridSizeZ as number) / 2)\n\n        const eAA = electricFieldX[xa][ya][z] * electricFieldX[xa][ya][z] + electricFieldY[xa][ya][z] * electricFieldY[xa][ya][z] + electricFieldZ[xa][ya][z] * electricFieldZ[xa][ya][z]\n        const eAB = electricFieldX[xa][yb][z] * electricFieldX[xa][yb][z] + electricFieldY[xa][yb][z] * electricFieldY[xa][yb][z] + electricFieldZ[xa][yb][z] * electricFieldZ[xa][yb][z]\n        const eBA = electricFieldX[xb][ya][z] * electricFieldX[xb][ya][z] + electricFieldY[xb][ya][z] * electricFieldY[xb][ya][z] + electricFieldZ[xb][ya][z] * electricFieldZ[xb][ya][z]\n        const eBB = electricFieldX[xb][yb][z] * electricFieldX[xb][yb][z] + electricFieldY[xb][yb][z] * electricFieldY[xb][yb][z] + electricFieldZ[xb][yb][z] * electricFieldZ[xb][yb][z]\n\n        // Magnetic field is offset from electric field, so get value at +0.5 by interpolating 0 and 1\n        const magXAA = (magneticFieldX[xa][ya][z] + magneticFieldX[xa+1][ya+1][z]) / 2\n        const magYAA = (magneticFieldY[xa][ya][z] + magneticFieldY[xa+1][ya+1][z]) / 2\n        const magZAA = (magneticFieldZ[xa][ya][z] + magneticFieldZ[xa+1][ya+1][z]) / 2\n        const magXAB = (magneticFieldX[xa][yb][z] + magneticFieldX[xa+1][yb+1][z]) / 2\n        const magYAB = (magneticFieldY[xa][yb][z] + magneticFieldY[xa+1][yb+1][z]) / 2\n        const magZAB = (magneticFieldZ[xa][yb][z] + magneticFieldZ[xa+1][yb+1][z]) / 2\n        const magXBA = (magneticFieldX[xb][ya][z] + magneticFieldX[xb+1][ya+1][z]) / 2\n        const magYBA = (magneticFieldY[xb][ya][z] + magneticFieldY[xb+1][ya+1][z]) / 2\n        const magZBA = (magneticFieldZ[xb][ya][z] + magneticFieldZ[xb+1][ya+1][z]) / 2\n        const magXBB = (magneticFieldX[xb][yb][z] + magneticFieldX[xb+1][yb+1][z]) / 2\n        const magYBB = (magneticFieldY[xb][yb][z] + magneticFieldY[xb+1][yb+1][z]) / 2\n        const magZBB = (magneticFieldZ[xb][yb][z] + magneticFieldZ[xb+1][yb+1][z]) / 2\n\n        const mAA = magXAA * magXAA + magYAA * magYAA + magZAA * magZAA\n        const mAB = magXAB * magXAB + magYAB * magYAB + magZAB * magZAB\n        const mBA = magXBA * magXBA + magYBA * magYBA + magZBA * magZBA\n        const mBB = magXBB * magXBB + magYBB * magYBB + magZBB * magZBB\n\n        const eMixTop = alphaX * eBA + (1 - alphaX) * eAA\n        const eMixBottom = alphaX * eBB + (1 - alphaX) * eAB\n        const eMix = Math.max(0, Math.min(25, alphaY * eMixBottom + (1 - alphaY) * eMixTop))\n\n        const mMixTop = alphaX * mBA + (1 - alphaX) * mAA\n        const mMixBottom = alphaX * mBB + (1 - alphaX) * mAB\n\n        const mMix = Math.max(0, Math.min(25, alphaY * mMixBottom + (1 - alphaY) * mMixTop))\n\n        this.color(eMix / 25, 0, mMix / 25)\n    }, { output: canvasSize, constants: { gridSizeX: gridSize[0], gridSizeY: gridSize[1], gridSizeZ: gridSize[2] }, graphical: true })\n\nfunction clamp(min: number, max: number, value: number) {\n    return Math.max(min, Math.min(max, value))\n}\n\nlet renderSim: any = null\n\nexport default function () {\n    const drawCanvasRef = useRef<HTMLCanvasElement>(null)\n\n    const [mouseDownPos, setMouseDownPos] = useState<[number, number] | null>(null)\n\n    const getSignal = useMemo(() => {\n        return (t: number) => {\n            return [0, 0, 50 * 60]\n        }\n    }, [])\n\n    const step = useCallback(() => {\n        let stop = false\n\n        const loop = (async () => {\n            await new Promise(resolve => setTimeout(resolve, 1000 * dt))\n\n            while (!stop) {\n                const simData = simulator.getData()\n\n                if (mouseDownPos !== null && drawCanvasRef.current) {\n                    const sig = getSignal(simData.time)\n\n                    const px = clamp(0, simData.electricFieldX.length - 1, Math.floor(simData.electricFieldX.length * mouseDownPos[0] / drawCanvasRef.current.width))\n                    const py = clamp(0, simData.electricFieldX[0].length - 1, Math.floor(simData.electricFieldX[0].length * mouseDownPos[1] / drawCanvasRef.current.height))\n\n                    for (let z = 0; z < simData.electricFieldX[0][0].length; z++) {\n                        simData.electricFieldX[px][py][z] += sig[0] * dt / 2\n                        simData.electricFieldY[px][py][z] += sig[1] * dt / 2\n                        simData.electricFieldZ[px][py][z] += sig[2] * dt / 2\n                    }\n                }\n\n                simulator.stepMagnetic(dt)\n\n                if (mouseDownPos !== null && drawCanvasRef.current) {\n                    const sig = getSignal(simData.time)\n\n                    const px = clamp(0, simData.electricFieldX.length - 1, Math.floor(simData.electricFieldX.length * mouseDownPos[0] / drawCanvasRef.current.width))\n                    const py = clamp(0, simData.electricFieldX[0].length - 1, Math.floor(simData.electricFieldX[0].length * mouseDownPos[1] / drawCanvasRef.current.height))\n\n                    for (let z = 0; z < simData.electricFieldX[0][0].length; z++) {\n                        simData.electricFieldX[px][py][z] += sig[0] * dt / 2\n                        simData.electricFieldY[px][py][z] += sig[1] * dt / 2\n                        simData.electricFieldZ[px][py][z] += sig[2] * dt / 2\n                    }\n                }\n\n                simulator.stepElectric(dt)\n\n                if (renderSim === null && drawCanvasRef.current !== null) {\n                    renderSim = makeRenderSimulatorCanvas(new GPU({ mode: \"webgl2\", canvas: drawCanvasRef.current }))\n                }\n\n                if (renderSim !== null) {\n                    renderSim(simData.electricFieldX, simData.electricFieldY, simData.electricFieldZ,\n                        simData.magneticFieldX, simData.magneticFieldY, simData.magneticFieldZ)\n                }\n\n                await new Promise(resolve => setTimeout(resolve, 1000 * dt))\n            }\n        })\n\n        loop()\n\n        return () => { stop = true }\n    }, [getSignal, mouseDownPos])\n\n    useEffect(step, [step])\n\n    return (\n        <canvas width={canvasSize[0]} height={canvasSize[1]} ref={drawCanvasRef}\n            onMouseDown={e => setMouseDownPos([e.clientX, canvasSize[1] - e.clientY])}\n            onMouseMove={e => { if (mouseDownPos !== null) setMouseDownPos([e.clientX, canvasSize[1] - e.clientY]) }}\n            onMouseUp={_ => setMouseDownPos(null)} />\n    )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}